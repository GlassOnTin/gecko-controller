# Gecko Controller Build System Improvements

## Current Issues

1. **Scattered Build Logic**
   - Build steps spread across multiple files:
     - build_deb.sh
     - debian/rules
     - debian/postinst
     - setup.py
   - No clear separation of concerns
   - Hard to track where specific steps are happening

2. **Node.js/npm Integration Problems**
   - npm ci failing due to missing package-lock.json
   - Frontend build process not properly integrated
   - No fallback mechanisms for build failures

3. **Dependency Management**
   - Mixed Python and Node.js dependencies
   - No clear dependency resolution order
   - Missing version pinning

## Proposed Solution

### 1. Centralized Build Management

Create a new `build` directory with the following structure:
```
build/
  ├── scripts/
  │   ├── build.py        # Main build orchestrator
  │   ├── frontend.py     # Frontend build utilities
  │   ├── backend.py      # Backend build utilities
  │   └── package.py      # Debian packaging utilities
  ├── config/
  │   ├── requirements.txt    # Python dependencies
  │   ├── package.json        # Node.js dependencies
  │   └── debian/            # Debian packaging configs
  └── Makefile              # High-level build targets
```

### 2. Makefile Targets

```makefile
.PHONY: all clean build test package

all: clean build test package

clean:
	python3 build/scripts/build.py clean

build: build-backend build-frontend

build-backend:
	python3 build/scripts/build.py backend

build-frontend:
	python3 build/scripts/build.py frontend

test:
	python3 build/scripts/build.py test

package:
	python3 build/scripts/build.py package
```

### 3. Build Script Implementation

The main `build.py` script should:
1. Implement proper logging and error handling
2. Handle dependency resolution
3. Manage build artifacts
4. Provide consistent interface for all build operations

Example implementation pattern:
```python
class BuildManager:
    def __init__(self):
        self.logger = self._setup_logging()
        self.config = self._load_config()

    def run(self, command):
        try:
            if command == 'clean':
                self._clean()
            elif command == 'backend':
                self._build_backend()
            elif command == 'frontend':
                self._build_frontend()
            # ... etc
        except BuildError as e:
            self.logger.error(f"Build failed: {e}")
            sys.exit(1)

    def _build_frontend(self):
        # 1. Check npm/node installation
        # 2. Install dependencies with fallback to npm install if ci fails
        # 3. Run production build
        # 4. Copy artifacts to correct location
```

### 4. Frontend Build Improvements

1. **Package Management**
   - Add package-lock.json to version control
   - Pin all dependency versions
   - Add fallback to `npm install` if `npm ci` fails

2. **Build Process**
   - Pre-build validation steps
   - Clear separation of development and production builds
   - Proper error handling and reporting

3. **Integration**
   - Move frontend build artifacts to a consistent location
   - Add validation of built artifacts
   - Include frontend tests in build process

### 5. Debian Packaging Improvements

1. Move debian-specific logic to `build/config/debian/`
2. Create clear separation between build and packaging steps
3. Implement proper versioning strategy
4. Add validation steps for package contents

### 6. Implementation Plan

1. **Phase 1: Build System Setup**
   - Create new build directory structure
   - Implement basic Makefile
   - Create main build.py script

2. **Phase 2: Frontend Integration**
   - Move frontend build process to new system
   - Add proper dependency management
   - Implement build validation

3. **Phase 3: Backend Integration**
   - Move backend build process to new system
   - Implement Python package building
   - Add test integration

4. **Phase 4: Packaging**
   - Move debian packaging to new system
   - Implement version management
   - Add package validation

### 7. Error Handling

Implement comprehensive error handling:
```python
class BuildError(Exception):
    """Base class for build errors"""
    pass

class FrontendBuildError(BuildError):
    """Frontend build specific errors"""
    pass

class BackendBuildError(BuildError):
    """Backend build specific errors"""
    pass

class PackagingError(BuildError):
    """Packaging specific errors"""
    pass
```

### 8. Logging and Reporting

Implement structured logging:
```python
def _setup_logging(self):
    logger = logging.getLogger('build')
    logger.setLevel(logging.INFO)

    # Console handler
    ch = logging.StreamHandler()
    ch.setFormatter(logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    ))
    logger.addHandler(ch)

    # File handler
    fh = logging.FileHandler('build.log')
    fh.setFormatter(logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    ))
    logger.addHandler(fh)

    return logger
```

## Benefits

1. **Centralized Control**
   - Single entry point for all build operations
   - Clear separation of concerns
   - Easier to maintain and debug

2. **Improved Reliability**
   - Proper error handling
   - Build validation
   - Fallback mechanisms

3. **Better Development Experience**
   - Clear build targets
   - Consistent interface
   - Better error reporting

4. **Maintainability**
   - Organized code structure
   - Proper separation of concerns
   - Clear documentation
